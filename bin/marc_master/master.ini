# -----------------------------------------------------------------------------------------------------------------
# MARC是一个分布式的运行框架，由三个部分组成：Master节点、Result节点和Client节点。MARC中的几个字母分别表示：
# M - Master, A - Application, R - Resut, C - Client。其具体的功能简要描述如下。
# 【Master】
# Master是整个框架的“管理者”，在整个框架中只有一个Master节点（可配置一个备份节点），其职责是：
# (1) 接收各Client节点、Result节点的注册请求和运行状态信息；
# (2) 在Client节点需要任务时自动调用用户编写的任务生成程序，并将其生成的任务下发给Client节点；
# (3) 将任务执行结果的存储服务地址告知Client节点（即相应的Result节点地址）；
# (4) 监控各个Client节点的任务执行情况，等等。
# 【Application】
# Application为用户的应用程序。MARC系统只是一个运行框架，具体用来干什么，是用户应用程序所赋予的功能。具体来说，
# MARC框架的使用者可按照MARC提供的接口规范分别编写部署在Master节点上的“任务生成程序”、部署在Client节点上的
# “任务执行程序”和部署在Result节点上的“结果处理程序”，这三个用户应用程序与MARC框架共同组成了一个基于任务的分布
# 式运行系统，其基本流程是：“任务生成->任务下载->任务执行->结果回传->结果存储”，具体地：
# (1) 任务生成：在Master节点，MARC框架会自动监测每个Client节点的任务执行状况，当某个Client节点需要任务时，
#      MARC框架会自动调用用户的“任务生成程序”。
# (2) 任务下载：当Client节点从Master节点获知其任务生成完成后，Client节点自动从Master节点下载生成的任务数据。
#      为提高传输效率，任务数据首先在Master节点经过压缩处理，Client节点接收完成后再进行解压。
# (3) 任务执行：Client节点得到任务后，MARC框架会自动调用用户的任务执行程序（以异步、非阻塞的方式执行）。
# (4) 结果回传：Client节点的任务执行程序运行完成后，MARC框架会自动将任务执行的结果上传到Result节点（Master节点
#      会告知Client节点其任务执行结果应该上传到哪个Result节点）。
# (5) 结果处理：Result节点在接收完Client节点上传的任务执行结果后，会自动调用用户的“结果处理程序”，完成比如结果
#      入库或其他的处理工作。
# 以上各个过程之间是可以并行进行的，比如，可以设置为异步上传策略，这样当任务执行完成后，可以马上获取新任务而不必
# 等待结果上传完毕。
# 【Result】
# Result节点是整个框架的结果收集和处理端，在整个MARC框架中可以是一个或者多个节点。负责接收Client节点上传的任务
# 执行结果，并自动调用用户的结果处理程序完成对任务执行结果的处理工作。
# 【Client】
# Client节点是MARC框架中的任务执行端，在整个MARC框架中可以部署多个Client节点。负责执行Master节点下发的任务。
# 
# 开发者：丁国栋，dingguodong@ict.ac.cn, gdding@hotmail.com
# -----------------------------------------------------------------------------------------------------------------


[basic]
# 当前Master节点绑定的IP和主监听端口
# 注意几点：
# (1) IP可设置为0.0.0.0，此时可接收所有网络接口上的请求，否则只绑定到指定的网络接口。
# (2) Port为主监听端口，用来接收Client/Result节点注册请求、Result节点的心跳信息和资源状态信息以及异常日志等。
# (3) Master节点除了开启一个主监听端口外，还会开启一个任务下载端口，用于Client节点下载任务数据。
#     任务下载端口的端口号为主监听端口+1（若被占用则继续+1），不需要在配置文件中设置。
# (4) Master节点还会开启若干个"从监听端口"（个数由MaxListenerCount设置，缺省为10），
#     开启多个“从监听端口”的目的主要是为了在Client节点数较多的情况下进行负载均衡及横向扩展。
# (5) "从监听端口"只用于与Client节点进行通讯，接收client节点的心跳信息、资源状态、异常日志、任务请求、运行状态等。
# (6) "从监听端口"的端口号不需要在配置文件中设置，由Master自行获得，从任务下载端口+1开始依次递增计算得到，
#     比如若任务下载端口号为6601，则获得的从监听端口号为6602,6603,...,6611。若中间某个端口号被其他进程占用，
#     则放弃该端口号继续累加获得，如6603被其他进程占用，则获得的从监听端口号为6602,6604,6605,...,6612。
# (7) Linux下可通过"netstat -an -p | grep marc"命令查看marc进程所占用的端口号。
IP=0.0.0.0
Port=6600


# ----------------------------------------------------------------------------
# HTTP服务方便管理员查看框架运行情况
# ----------------------------------------------------------------------------
[httpd]

# 非0时开启HTTP服务，缺省为1
Enabled=1

# HTTP服务端口(Enabled为1时才有意义)，缺省为6680
Port=6680

# -----------------------------------------------------------------------------------------------------------------
# 以下为各个类型应用程序对应的任务生成命令，用户需要在这里为各个注册到当前Master节点的Client节点的应用程序类型
# 配置其对应的任务生成程序，格式为: [AppType]=[AppCmd]，如："NewsGather=./NewsTaskCreate"（表示Client
# 节点应用程序类型为"NewsGather"的任务生成命令为"./NewsStore"）。其中：
#      ---- [AppType]表示Client节点的用户应用程序类型（对应client.ini中的AppType参数），如"NewsGather"。
#      ---- [AppCmd]表示对应的任务生成命令，如"./NewsTaskCreate"，须包含相对路径或绝对路径，可以有自带参数。
# 当Client节点需要任务时，MARC框架会自动调用相应类型的任务生成命令，调用接口为: [AppCmd] [TaskDirPath] [ClientID] 
# 如"./NewsTaskCreate ./task/1_NewsGather_task_20100204095923/ 1"，其中：
#      ---- [TaskDirPath]用于存放任务生成程序的执行结果（被Client节点下载后，即为Client节点的input文件夹）; 
#      ---- [ClientID]是需要任务的Client节点ID
# 注意几点：
# (1) 任务生成命令不需要自己创建[TaskDirPath]文件夹，MARC框架会先行自动创建。
# (2) 任务生成命令执行成功后，须在[TaskDirPath]文件夹中生成".success"文件，否则MARC框架将不会将其下发给Client节点。
# (3) AppType是大小写敏感的。
# -----------------------------------------------------------------------------------------------------------------
[appcmd]

#Client节点的应用程序类型为"Test"的任务生成命令
Test=./TaskCreateTest.bat

#Client节点的应用程序类型为"ForumGather"的任务生成命令
ForumGather=./ForumTaskCreate

#Client节点的应用程序类型为"NewsGather"的任务生成命令
NewsGather=./NewsTaskCreate


# -----------------------------------------------------------------------------------------------------------------
# 以下部分用于进行应用程序版本升级。
# Master节点将在[ClientUpdateDir]以及[ResultUpdateDir]下自动为当前活跃的所有Client节点所属的AppType创建一个子目录，
# 管理员可在其子目录下放置升级包，每个升级包对应一个文件夹，以版本号命名，最小版本号是1，
# 如"./update_client/NewsGather/2/"存放AppType为"NewsGather"的版本号为2的升级包文件夹。
# 注意几点：
# (1) 管理员在确认升级包可用时，须在升级包的文件夹中生成一个空的标志文件"update.ok"，否则框架将忽略该升级包。比如上述
#     版本号为2的升级包在管理员确认可用后，应在"./update_client/NewsGather/2/"文件夹下创建一个"update.ok"空文件。
# (2) 每个AppType的每个升级包版本不建议以patch补丁形式提供，而是均为完整版本，这样，在框架的长期运行过程中，中途新增的
#     Client节点才能得到最完整的App版本（目前的实现机制是Client在向Master请求升级App时，只从Master上下载最新的升级包，
#     然后替换Client节点上相应的文件或文件夹）。
# (3) Master会为每个升级包进行压缩，压缩的升级包文件存放在每个AppType的对应文件夹中，如"./update_client/NewsGather/2/"
#     的升级包压缩文件为"NewsGather_2.myzip"，存放在"./update_client/NewsGather/"下。
# (4) 管理员在创建新的升级包时，应确保其版本号（即升级包文件夹名称）大于之前的最大版本号（可通过升级包压缩文件名来判断）
# (5) 如果同一时刻在某个AppType有多个版本号的升级包，则框架只保留版本号最大的那个升级包。
# (6) 每个升级包中如果有可执行文件，须确保其具有可执行权限(Linux下的"chmod +x"命令可修改成可执行）。
# (7) 每个升级包压缩文件下载到Client节点或Result节点后，框架自动解压到[UpdateTargetPath]下（参见client.ini和result.ini）。
# -----------------------------------------------------------------------------------------------------------------
[update]

# Client节点应用程序升级包的存放路径
ClientUpdateDir=./update_client/

# Result节点应用程序升级包的存放路径
ResultUpdateDir=./update_result/

# 每隔多少秒扫描是否有应用程序升级包
VerWatchInterval=10


# ------------------------------------------
# 以下部分为Master节点高级配置，一般来说不用改动
# ------------------------------------------
[advanced]

# 开启的从监听服务数（不小于1）
MaxListenerCount=1

# 任务生成路径（存放执行任务生成程序后的结果）
TaskDir=./task/

# 任务压缩路径（存放压缩后的任务文件）
ZipTaskDir=./myzip_task/

# 任务生成机制
# 0: 只要Client节点没有待处理任务，就为其生成新任务
# 1: 只有等Client节点主动请求任务且当前没有待处理任务时才为其生成新任务
TaskCreateStrategy=1

# 任务下发时长（从任务被Client节点请求开始到当前时间）最大值（秒数）
# 超过该值的任务将被认为失败任务，设置为0时不限制任务下发时间长短
MaxTaskFetchTime=300

# 已下发任务执行时长(从任务被下发到Client节点开始算起到当前时间)最大值(秒数)
# 超过该值的任务将被认为执行失败，设置为0时不限时
MaxTaskRunTime=3600

# 多长时间保存一次Client节点应用程序状态(秒数)
MaxSaveStateTime=600

#任务下载时每个数据包的最大字节数（不小于4096）
MaxPacketSize=4096

# [appcmd]中的各个任务生成程序的执行时限(秒)，为0时不限时
AppRunTimeout=60

# 非0时自动删除已处理完的任务压缩文件
AutoDeleteTaskFile=1

# 设置失败任务的处理策略。一个任务失败可能由下列原因引起：
# （1）Master节点检测到任务下载超时（当参数MaxTaskFetchTime非0时），由Master节点自行判定该任务为失败任务；
# （2）Master节点检测到任务执行超时（当参数MaxTaskRunTime非0时），由Master节点自行判定该任务为失败任务；
# （3）因某个Client节点正常退出或崩溃或网络异常等原因造成Client节点与Master的连接断开，
#      由Master节点自行判定该Client节点当时正被执行的任务和后续待处理任务都是失败任务；
# （4）Client节点检测到任务没有被成功下载，由Client节点告知Master节点该任务为失败任务；
# （5）Client节点检测到任务执行程序运行超时，由Client节点告知Master节点该任务为失败任务；
# （6）在Client节点上，因下列原因造成任务执行应用程序运行失败，由Client节点告知Master节点该任务失败：
#      ---- 对下载完成的任务文件解压失败（检查myzip是否存在且有可执行权限）；
#      ---- client.ini中设置的任务执行命令[AppCmd]调用失败（请检查[AppCmd]是否能在命令行下单独运行成功）;
#      ---- 任务执行程序运行结束，但当前目录下没发现.success文件；
#      ---- 任务执行完成，但结果文件夹[output]压缩失败（检查myzip是否存在且有可执行权限）；
# 参数的取值及含义：
# 0: 忽略该任务，不再处理（缺省）
# 1: 只能被同一个Client节点重新执行该任务（注：Master节点基于ClientID判断是否为同一个Client节点）
# 2: 允许同一类型的其他Client节点（即client.ini中的AppType相同）重新执行该任务
TaskFailStrategy=2

# 失败任务的重试次数，超过则抛弃，为0时不限定重试次数
# 该参数只有在TaskFailStrategy非0时才有意义
TaskFailMaxRetry=3

# Master节点终止时是否记录未处理和失败的任务信息
# 0 - 不记录，未处理和失败的任务被抛弃，Master节点下次启动时不再重新载入
# 1 - 记录到临时文件，下次Master节点下次启动时重新载入
AutoSaveUnfinishedTask=1

# 每隔多长时间监控Master节点资源使用状态信息（秒）
SourceStatusInterval=300
